<!DOCTYPE html>
<!-- Legal Footnote: This content is subject to copyright and should not be reproduced without permission. -->
<!-- Written and created by Thomas John-Michael de Beer, feel free to contact me via tjdebeer@gmail.com  -->
<html lang="en">
<head>
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content=" ⧉ ARCHIVE URLS TO IMAGES ⧉">
    <meta name="keywords" content="images, sharing, camera, free, upload, map, frame, archive, save, link, scan, frame-archive, art, music, videos, ⧉">
    <title>⧉</title>
    <link rel="icon" type="image/png" href="favicon.png">
<style>
        body {
            -webkit-overflow-scrolling: touch;
            overflow: hidden;
            position: fixed;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            margin: 0;
        }
        
#cameraViewContainer {
            width: 41vh;
            height: 41vh;
            position: absolute;
            overflow: hidden;
            background-color: transparent;
            z-index: 9;
            left: 50%;
            transform: translateX(-50%); 
            top: 32%; 
        }

#cameraView {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: transparent;
        }

#startCameraButton {
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            color: white;
            border: none;
            cursor: pointer;
            outline: none;
            opacity: 1;
            transition: opacity 2.2s;
            z-index: 13;
        }

#startCameraButton img {
    width: 222px;
    height: auto;
}

#startCameraButton:hover {
            opacity: 1;
        }

#MenuButton {
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    position: absolute;
    top: 14%;
    left: 18%;
    transform: translate(-50%, -50%);
    background-color: black;
    color: white;
    width: 44px;
    height: 44px;
    font-size: 2.5rem;
    font-family: Arial, Helvetica, sans-serif;
    border-radius: 50%;
    padding: 0;
    border: none;
    cursor: pointer;
    outline: none;
    z-index: 5;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0.3;
    transition: opacity 3s;
}

#MenuButton:hover {
    opacity: 0.9;
}

#takePhotoButton {
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    position: absolute;
    top: 88%;
    right: 18%;
    transform: translate(+50%, -50%);
    background-color: transparent;
    color: white;
    width: 62px;
    height: 62px;
    border: none;
    cursor: pointer;
    outline: none;
    z-index: 5;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.6s;
    pointerEvents = 'none';
}

#openTextInputButton {
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    position: absolute;
    top: 88%;
    left: 18%;
    transform: translate(-50%, -50%);
    background-color: transparent;
    color: white;
    width: 55px;
    height: 55px;
    border: none;
    cursor: pointer;
    z-index: 5;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 1.1s;
}

#textInputContainer {
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translate(-50%, -0%);
    background-color: rgba(255, 255, 255, 0);
    width: 69%;
    height: 200px;
    display: none;
    z-index: 88;
}

#roundedTextInput {
    display: flex;
    align-items: center;
}

#textInput {
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    flex-grow: 1;
    border: none;
    border-radius: 22px;
    padding: 11px;
    text-align: center;
}

#ShareButton {
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    position: absolute;
    top: 14%;
    right: 18%;
    transform: translate(+50%, -50%);
    background-color: transparent;
    color: white;
    width: 55px;
    height: 55px;
    border: none;
    cursor: pointer;
    outline: none;
    z-index: 8;
    opacity: 0;
    transition: opacity 1.1s;
}

#QRContainer {
    position: absolute;
    top: 53%;
    left: 50%;
    z-index: 10;
    transform: translate(-50%, -50%);
    display: none;
}

#QRImage {
    width: 42vh;
    height: auto;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

#openButton {
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: transparent;
    color: white;
    width: 144px;
    height: 144px;
    border: none;
    cursor: pointer;
    z-index: 9;
    opacity: 0;
    transition: opacity 3.3s ease-in-out, visibility 0s 1s;
        }

#openButton:hover {
            opacity: 0.9;
            transition: opacity 3.3s ease-in-out;
        }

</style>

</head>

<body>

<div id="BLACK_SCREEN"></div>

    <button id="ShareButton">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <path fill="#FFFFFF" d="M78.5,63.9c-4.6,0-8.8,1.9-11.8,5L37.3,53.2c0.2-1.1,0.4-2.3,0.4-3.5c0-1.2-0.1-2.3-0.3-3.4L66.6,31
	            c3,3.2,7.2,5.1,11.9,5.1c9.1,0,16.4-7.3,16.4-16.4S87.6,3.3,78.5,3.3s-16.4,7.3-16.4,16.4c0,1.2,0.1,2.3,0.3,3.4L33.2,38.4
	            c-3-3.2-7.2-5.1-11.9-5.1c-9.1,0-16.4,7.3-16.4,16.4S12.2,66,21.3,66c4.6,0,8.8-1.9,11.8-5l29.4,15.7c-0.2,1.1-0.4,2.3-0.4,3.5
	            c0,9.1,7.3,16.4,16.4,16.4s16.4-7.3,16.4-16.4S87.6,63.9,78.5,63.9z"/>
        </svg>
</button>

<div id="QRContainer" style="display: none;">
        <img src="QR.png">
</div>


<div id="textInputContainer" style="display: none;">
        <div id="roundedTextInput">
            <input type="text" id="textInput" placeholder="" value="" autocapitalize="none">
        </div>
    </div>

    <button id="openTextInputButton">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <polygon fill="#FFFFFF" points="94.3,44.4 55.9,44.4 55.9,6 44.1,6 44.1,44.4 5.7,44.4 5.7,56.3 44.1,56.3 44.1,94.7 55.9,94.7 
                55.9,56.3 94.3,56.3"/>
        </svg>
</button>

<div id="cameraViewContainer">
        <video id="cameraView" autoplay></video>
    </div>

<button id="startCameraButton" onclick="toggleFullscreen()">
        <img src="presplash.webp">
</button>

    <button id="MenuButton" onclick="toggleMenu()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <path fill="#FFFFFF" d="M63.1,36.9V4.5H4.5v58.6h32.3v32.3h58.6V36.9H63.1z M10.7,56.9V10.7h46.2v26.1h-20v20.1H10.7z M56.9,43.1V57
                H43.1V43.1H56.9z M89.3,89.3H43.1V63.1h20.1v-20h26.1C89.3,43.1,89.3,89.3,89.3,89.3z"/>
        </svg>
    </button>

<button id="takePhotoButton" onclick="takePhoto(); setTemporaryOpacity(this, 0.4, 222);">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <circle opacity="0.33" fill="#FFFFFF" cx="50" cy="50" r="45"/>
            <circle opacity="0.9" fill="#FFFFFF" cx="50" cy="50" r="35.7"/>
        </svg>
    </button>

    <canvas id="photoCanvas" style="display: none;"></canvas>

<button id="openButton" onclick="open_file_chooser()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <path fill="#FFFFFF" d="M63.1,36.9V4.5H4.5v58.6h32.3v32.3h58.6V36.9H63.1z M10.7,56.9V10.7h46.2v26.1h-20v20.1H10.7z M56.9,43.1V57
                H43.1V43.1H56.9z M89.3,89.3H43.1V63.1h20.1v-20h26.1C89.3,43.1,89.3,89.3,89.3,89.3z"/>
        </svg>
</button>

</body>
<script>

const shareButton = document.getElementById('ShareButton');
const qrContainer = document.getElementById('QRContainer');

shareButton.addEventListener('click', () => {
QRContainer.style.display = QRContainer.style.display === 'none' ? 'block' : 'none';
shareButton.style.opacity = shareButton.style.opacity === '0.3' ? '0.9' : '0.3';
});

function setTemporaryOpacity(element, opacity, duration) {
    element.style.opacity = opacity;
    setTimeout(function () {
        element.style.opacity = 0.9;
    }, duration);
}

function open_file_chooser() {
    disableFullscreenChangeListener();

    if (intervalId) {
        clearInterval(intervalId);
    }

    var fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "image/*";
    fileInput.click();

    fileInput.addEventListener("change", function () {
        var selectedFile = this.files[0];
        if (selectedFile) {
                processAndSendImage(selectedFile);
            if (intervalCallback) {
                if (MENUVAR === 0) {
                    intervalId = setInterval(intervalCallback, 333);
                } else {
                    clearInterval(intervalId);
                }
            }
        }
    });

    fileInput.addEventListener("cancel", function () {
        enableFullscreenChangeListener();
        toggleFullscreen();
    });
}

function processAndSendImage(selectedFile) {
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    var img = new Image();

    img.onload = function () {
        const borderSize = 10;
        canvas.width = img.width + 2 * borderSize;
        canvas.height = img.height + 2 * borderSize;
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, borderSize, borderSize, img.width, img.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const transformedImageData = processImage(imageData);
        const processedImageArray = SequenceandSend(transformedImageData);

        if (processedImageArray) {
            if (SAVED_LINK.trim() === '') {
                FRAME(processedImageArray);
            } else {
                ARCHIVE(processedImageArray, SAVED_LINK);
            }
        } else {
            console.error('Processed image is undefined. Cannot proceed.');
        }
    };

    img.src = URL.createObjectURL(selectedFile);
}

const openTextInputButton = document.getElementById('openTextInputButton');
const textInputContainer = document.getElementById('textInputContainer');
const textInput = document.getElementById('textInput');

let SAVED_LINK = '';

openTextInputButton.addEventListener('click', () => {
        openTextInputButton.style.opacity = 0.7;
        textInputContainer.style.display = 'block';
        textInput.focus();
        textInput.placeholder = SAVED_LINK;
});

textInput.addEventListener('input', () => {
    SAVED_LINK = textInput.value;
    updateOpenButtonOpacity();
});

textInput.addEventListener('keydown', (event) => {
    if (event.key === 'Enter' || event.key === 'Go') {
        textInputContainer.style.display = 'none';
        textInput.value = '';
        updateOpenButtonOpacity();
    }
});

function updateOpenButtonOpacity() {
    if (SAVED_LINK && SAVED_LINK.trim() !== '') {
        openTextInputButton.style.opacity = '0.9';
    } else {
        openTextInputButton.style.opacity = '0.2';
    }
}

let intervalId;
let intervalCallback;
let CameraStatus = false;
const cameraView = document.getElementById('cameraView');
const startCameraButton = document.getElementById('startCameraButton');
const takePhotoButton = document.getElementById('takePhotoButton');
const photoCanvas = document.getElementById('photoCanvas');
const canvasContext = photoCanvas.getContext('2d');
let stream;
let currentCameraIndex = 0;

async function startCamera() {
    try {
        let selectedDeviceId = localStorage.getItem('selectedCamera');

        if (!selectedDeviceId) {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            if (videoDevices.length === 0) {
                throw new Error('No video devices found.');
            }

            currentCameraIndex = videoDevices.length > 1 ? 1 : 0;
            selectedDeviceId = videoDevices[currentCameraIndex].deviceId;

            localStorage.setItem('selectedCamera', selectedDeviceId);
        }

        const constraints = {
            video: { deviceId: selectedDeviceId },
            audio: false,
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraView.srcObject = stream;
        startCameraButton.disabled = true;
        takePhotoButton.disabled = false;
        startCameraButton.style.display = 'none';
        CameraStatus = true;

        intervalCallback = () => {
            takePhoto();
        };
        intervalId = setInterval(intervalCallback, 333);

    } catch (error) {
        startCameraButton.disabled = true;
        startCameraButton.style.opacity = '0';
        startCameraButton.style.pointerEvents = 'none';
        takePhotoButton.disabled = true;
        takePhotoButton.style.opacity = '0';
        takePhotoButton.style.pointerEvents = 'none';
        console.error('Error starting camera:', error);
    }
}

async function switchCamera() {
    try {
        stopCamera();
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');

        if (videoDevices.length === 0) {
            throw new Error('No video devices found.');
        }

        currentCameraIndex = (currentCameraIndex + 1) % videoDevices.length;
        const selectedDeviceId = videoDevices[currentCameraIndex].deviceId;

        localStorage.setItem('selectedCamera', selectedDeviceId);

        await startCamera();
    } catch (error) {
        handleCameraError(error);
    }
}

function stopCamera() {
    clearInterval(intervalId);

    if (stream) {
        const tracks = stream.getTracks();
        tracks.forEach(track => {
            track.stop();
        });
    }
}

function handleSwipe() {
    const deltaY = touchendY - touchstartY;

    if (deltaY > 50) {
        switchCamera();
    }
}

document.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowUp') {
        switchCamera();
    }
});

let touchstartY;
let touchendY;

document.addEventListener('touchstart', (event) => {
    touchstartY = event.touches[0].clientY;
});

document.addEventListener('touchmove', (event) => {
    event.preventDefault();
});

document.addEventListener('touchend', (event) => {
    touchendY = event.changedTouches[0].clientY;
    handleSwipe();
});

startCameraButton.addEventListener('click', startCamera);

function toggleFullscreen() {
            const docElement = document.documentElement;

            if (docElement.requestFullscreen) {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    docElement.requestFullscreen().catch(err => {
                        console.error('Error attempting to enable fullscreen:', err);
                    });
                }
            }
        }

function takePhoto() {
    if (stream) {
        photoCanvas.width = cameraView.videoWidth;
        photoCanvas.height = cameraView.videoHeight;
        canvasContext.drawImage(cameraView, 0, 0, photoCanvas.width, photoCanvas.height);
        const imageData = canvasContext.getImageData(0, 0, photoCanvas.width, photoCanvas.height);
        const transformedImageData = processImage(imageData);
        const processedImageArray = SequenceandSend(transformedImageData);

        if (processedImageArray) {
            
            if (SAVED_LINK.trim() === '') {
                FRAME(processedImageArray);
            } else {
                ARCHIVE(processedImageArray, SAVED_LINK);
            }
        } else {
            console.error('Processed image is undefined. Cannot proceed.');
        }
    }
}

function processImage(srcImageData) {
    const { width, height, data } = srcImageData;
    const size = Math.min(width, height);
    const start_x = (width - size) / 2;
    const start_y = (height - size) / 2;
    const croppedImageData = cropImageData(srcImageData, start_x, start_y, size, size);
    const correctedFormat = resizeCanvas(croppedImageData, 507, 507, 5);
    const IMGDATAcroppedImageData = canvasToImageData(correctedFormat);
    const grayImageData = convertToGrayscale(IMGDATAcroppedImageData);
    const binaryImageData = applyThreshold(grayImageData);
    const largestContour = findLargestEnclosedArea(binaryImageData);

    if (largestContour) {
        const Quadrilateral = findQuadrilateral(largestContour);
        if (Quadrilateral.length === 4) {
            const transformedImageData = transcribePixels(correctedFormat, Quadrilateral);
            return transformedImageData;
        } else {
            console.error('Could not find a valid quadrilateral contour.');
            return null;
        }
    } else {
        console.error('Could not find a valid largest contour.');
        return null;
    }
}

function transcribePixels(correctedFormat, Quadrilateral) {
    const canvasSize = 512;
    const ctx = correctedFormat.getContext('2d');
    ctx.canvas.willReadFrequently = true;
    const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize);
    const reorderedQuadrilateral = [
        Quadrilateral[2],
        Quadrilateral[3],
        Quadrilateral[1],
        Quadrilateral[0]
    ];

    const destSquare = [
        { x: 0, y: 0 },
        { x: canvasSize - 1, y: 0 },
        { x: canvasSize - 1, y: canvasSize - 1 },
        { x: 0, y: canvasSize - 1 }
    ];

    const matrix = findHomographyMatrix(reorderedQuadrilateral, destSquare);
    const newCanvas = document.createElement('canvas');
    newCanvas.width = canvasSize;
    newCanvas.height = canvasSize;
    const newCtx = newCanvas.getContext('2d');
    applyPerspectiveTransform(ctx, newCtx, imageData, matrix, reorderedQuadrilateral);
    const croppedImageData = newCtx.getImageData(6, 6, canvasSize - 2 * 6, canvasSize - 2 * 6);
    return croppedImageData;
}

function findHomographyMatrix(srcPoints, destPoints) {
    const A = [];
    const destLength = destPoints.length;

    for (let i = 0; i < destLength; i++) {
        const { x, y } = destPoints[i];
        const { x: u, y: v } = srcPoints[i];

        A.push([x, y, 1, 0, 0, 0, -x * u, -y * u, u]);
        A.push([0, 0, 0, x, y, 1, -x * v, -y * v, v]);
    }

    const matrix = gaussianElimination(A);
    return [
        [matrix[0], matrix[1], matrix[2]],
        [matrix[3], matrix[4], matrix[5]],
        [matrix[6], matrix[7], matrix[8] || 1]
    ];
}

function gaussianElimination(matrix) {
    const numRows = matrix.length;
    const numCols = matrix[0].length;

    for (let i = 0; i < numRows; i++) {
        let pivotRow = i;
        while (pivotRow < numRows && matrix[pivotRow][i] === 0) {
            pivotRow++;
        }

        if (pivotRow === numRows) {
            continue;
        }

        [matrix[i], matrix[pivotRow]] = [matrix[pivotRow], matrix[i]];
        const diagonalElement = matrix[i][i];

        for (let j = i; j < numCols; j++) {
            matrix[i][j] /= diagonalElement;
        }

        for (let k = 0; k < numRows; k++) {
            if (k !== i) {
                const factor = matrix[k][i];
                for (let j = i; j < numCols; j++) {
                    matrix[k][j] -= factor * matrix[i][j];
                }
            }
        }
    }

    const solution = new Array(numRows);
    for (let i = 0; i < numRows; i++) {
        solution[i] = matrix[i][numCols - 1];
    }

    return solution;
}

function applyPerspectiveTransform(srcCtx, destCtx, imageData, matrix) {
    const canvasSize = imageData.width;
    const newImageData = destCtx.createImageData(canvasSize, canvasSize);
    const matrix0 = matrix[0];
    const matrix1 = matrix[1];
    const matrix2 = matrix[2];

    for (let y = 0; y < canvasSize; y++) {
        for (let x = 0; x < canvasSize; x++) {
            const newX = matrix0[0] * x + matrix0[1] * y + matrix0[2];
            const newY = matrix1[0] * x + matrix1[1] * y + matrix1[2];
            const newW = matrix2[0] * x + matrix2[1] * y + matrix2[2];
            const srcCoords = { x: newX / newW, y: newY / newW };

            const floorX = Math.floor(srcCoords.x);
            const floorY = Math.floor(srcCoords.y);
            const pixelIndex = (floorY * canvasSize + floorX) * 4;
            const destIndex = (y * canvasSize + x) * 4;

            const srcPixel = {
                r: imageData.data[pixelIndex],
                g: imageData.data[pixelIndex + 1],
                b: imageData.data[pixelIndex + 2],
                a: imageData.data[pixelIndex + 3]
            };

            newImageData.data[destIndex] = srcPixel.r;
            newImageData.data[destIndex + 1] = srcPixel.g;
            newImageData.data[destIndex + 2] = srcPixel.b;
            newImageData.data[destIndex + 3] = srcPixel.a;
        }
    }
    destCtx.putImageData(newImageData, 0, 0);
}

function cropImageData(srcImageData, start_x, start_y, width, height) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.putImageData(srcImageData, -start_x, -start_y);
    const croppedImageData = ctx.getImageData(0, 0, width, height);
    return croppedImageData;
}

function convertToGrayscale(imageData) {
    const pixels = imageData.data;
    const numPixels = pixels.length / 4;

    for (let i = 0; i < numPixels; i++) {
        const startIndex = i * 4;
        const red = pixels[startIndex];
        const green = pixels[startIndex + 1];
        const blue = pixels[startIndex + 2];
        const average = (red + green + blue) / 3;
        pixels[startIndex] = average;
        pixels[startIndex + 1] = average;
        pixels[startIndex + 2] = average;
    }
    return imageData;
}

function applyThreshold(grayImageData, threshold = 99) {
    const pixels = new Uint8ClampedArray(grayImageData.data);
    const numPixels = pixels.length / 4;

    for (let i = 0; i < numPixels; i++) {
        const startIndex = i * 4;
        const intensity = pixels[startIndex];
        const newValue = intensity >= threshold ? 255 : 0;
        pixels[startIndex] = newValue;
        pixels[startIndex + 1] = newValue;
        pixels[startIndex + 2] = newValue;
    }
    return new ImageData(pixels, grayImageData.width, grayImageData.height);
}

function resizeCanvas(imageOrCanvas, width, height, borderSize) {
    const canvas = document.createElement('canvas');
    canvas.width = width + 2 * borderSize;
    canvas.height = height + 2 * borderSize;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (imageOrCanvas instanceof ImageData) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = imageOrCanvas.width;
        tempCanvas.height = imageOrCanvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageOrCanvas, 0, 0);
        ctx.drawImage(
            tempCanvas,
            0,
            0,
            tempCanvas.width,
            tempCanvas.height,
            borderSize,
            borderSize,
            width,
            height
        );
    } else {
        ctx.drawImage(
            imageOrCanvas,
            0,
            0,
            imageOrCanvas.width,
            imageOrCanvas.height,
            borderSize,
            borderSize,
            width,
            height
        );
    }
    return canvas;
}

function canvasToImageData(canvas) {
    const ctx = canvas.getContext('2d');
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function findQuadrilateral(largestContour) {
    const centralPoint = findCentralPoint(largestContour);
    if (!centralPoint) {
        return null;
    }

    const topLeftCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x < centralPoint.x && y > centralPoint.y);
    const topRightCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x > centralPoint.x && y > centralPoint.y);
    const bottomLeftCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x < centralPoint.x && y < centralPoint.y);
    const bottomRightCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x > centralPoint.x && y < centralPoint.y);
    
    return [topLeftCorner, topRightCorner, bottomLeftCorner, bottomRightCorner];
}

function findCentralPoint(largestContour) {
    const totalPoints = largestContour.length;
    if (totalPoints === 0) {
        throw new Error('No points found in the largest contour.');
    }

    let sumX = 0;
    let sumY = 0;

    for (const point of largestContour) {
        sumX += point.x;
        sumY += point.y;
    }

    const centralX = sumX / totalPoints;
    const centralY = sumY / totalPoints;

    if (isNaN(centralX) || isNaN(centralY)) {
        throw new Error('Central point calculation resulted in NaN values.');
    }

    return { x: centralX, y: centralY };
}

function distanceSquared(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return dx * dx + dy * dy;
}

function findExtremePoint(largestContour, centralPoint, conditionFunction) {
    let extremePoint = null;
    let maxDistanceSquared = 0;

    for (const point of largestContour) {
        const { x, y } = point;

        if (conditionFunction(x, y)) {
            const currentDistanceSquared = distanceSquared(centralPoint, point);
            if (!extremePoint || currentDistanceSquared > maxDistanceSquared) {
                extremePoint = point;
                maxDistanceSquared = currentDistanceSquared;
            }
        }
    }
    return extremePoint;
}

function findLargestEnclosedArea(binaryImageData) {
    const contours = findContours(binaryImageData);
    const validContours = contours.filter(contour => contour.length >= 4);
    let maxArea = -1;
    let largestContour = null;

    validContours.forEach((contour, index) => {
        const area = calculateContourArea(contour);

        if (area > maxArea) {
            maxArea = area;
            largestContour = contour;
        }
    });

    if (!largestContour) {
        console.error('Could not find a valid largest contour.');
    }

    return largestContour;
}

function calculateContourArea(contour) {
    let area = 0;

    for (let i = 0; i < contour.length; i++) {
        const current = contour[i];
        const next = contour[(i + 1) % contour.length];
        area += (current.x * next.y - next.x * current.y);
    }
    return Math.abs(area) / 2;
}

function findContours(binaryImageData) {
    const width = binaryImageData.width;
    const height = binaryImageData.height;
    const visited = Array.from({ length: height }, () => Array(width).fill(false));
    const contours = [];

    function isValid(x, y) {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    function dfs(startX, startY) {
        const stack = [{ x: startX, y: startY }];
        const contour = [];

        while (stack.length > 0) {
            const { x, y } = stack.pop();

            if (isValid(x, y) && !visited[x][y]) {
                const index = (y * width + x) * 4;
                const intensity = binaryImageData.data[index];

                if (intensity === 0) {
                    visited[x][y] = true;
                    contour.push({ x, y });

                    stack.push({ x: x + 1, y });
                    stack.push({ x: x - 1, y });
                    stack.push({ x, y: y + 1 });
                    stack.push({ x, y: y - 1 });
                }
            }
        }

        return contour;
    }

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const intensity = binaryImageData.data[index];

            if (intensity === 0 && !visited[x][y]) {
                const contour = dfs(x, y);

                if (contour.length > 10) {
                    contours.push([...contour]);
                }
            }
        }
    }

    return contours;
}

function SequenceandSend(transformedImageData) {
    if (transformedImageData === undefined) {
        console.error('transformedImageData is undefined. Cannot proceed.');
        return;
    }
    const resizedWidth = 8;
    const resizedHeight = 8;
    const resizedImageData = resizeImage(transformedImageData, resizedWidth, resizedHeight);
    const processedImageArray = imageToFlatArray(resizedImageData);
    return processedImageArray;
}

function resizeImage(imageData, width, height) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    if (!(imageData instanceof ImageData)) {
        console.error('Invalid image source provided to resizeImage function:', imageData);
        return null;
    }

    canvas.width = width;
    canvas.height = height;

    try {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imageData.width;
        tempCanvas.height = imageData.height;
        tempCtx.putImageData(imageData, 0, 0);

        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, width, height);

        return ctx.getImageData(0, 0, width, height);
    } catch (error) {
        console.error('Error resizing image:', error.message);
        return null;
    }
}

function imageToFlatArray(imageData) {
    if (!imageData || !imageData.data) {
        console.error('Invalid imageData provided to imageToFlatArray function.');
        return null;
    }
    const { data } = imageData;
    const flatArray = [];

    for (let i = 0; i < data.length; i += 4) {
        flatArray.push(data[i], data[i + 1], data[i + 2]);
    }
    return flatArray;
}

function waveSequenceCohesion(weights, processedImageArray) {
    for (let i = 0; i < processedImageArray.length; i++) {
        if (Math.abs(processedImageArray[i] - weights[i]) >= 54) {
            return false;
        }
    }
    return true;
}

function ARCHIVE(processedImageArray, SAVED_LINK) {
    const request = indexedDB.open('myDatabase', 1);

    request.onsuccess = function (event) {
        const db = event.target.result;

        const transaction = db.transaction(['data'], 'readwrite');
        const objectStore = transaction.objectStore('data');
        const cursorRequest = objectStore.openCursor();

        cursorRequest.onsuccess = function (event) {
            const cursor = event.target.result;
            if (cursor) {
                const weights = cursor.value.weights;

                if (waveSequenceCohesion(weights, processedImageArray)) {
                    console.log('ARCHIVE already exists.');
                    return;
                }
                cursor.continue();
            } else {
                console.log('No matching record found.');
                const newData = { weights: processedImageArray, links: SAVED_LINK };
                const addRequest = objectStore.add(newData);

                addRequest.onsuccess = function () {
                    console.log('ARCHIVE added.');
                    UpdateIndex(JSON.stringify(newData));
                    SAVED_LINK = '';
                };

                addRequest.onerror = function (event) {
                    console.error('Error adding ARCHIVE:', event.target.error);
                };
            }
        };

        cursorRequest.onerror = function (event) {
            console.error('Error opening cursor:', event.target.error);
        };
    };

    request.onerror = function (event) {
        console.error('Error opening database:', event.target.error);
    };
}

    let isWindowOpen = false;

function FRAME(processedImageArray) {


    return new Promise((resolve, reject) => {
        const request = indexedDB.open('myDatabase', 1);

        request.onsuccess = function (event) {
            const db = event.target.result;

            const transaction = db.transaction(['data'], 'readonly');
            const objectStore = transaction.objectStore('data');
            const cursorRequest = objectStore.openCursor();

            cursorRequest.onsuccess = function (event) {
                const cursor = event.target.result;
                if (cursor) {
                    const weights = cursor.value.weights;
                    const link = cursor.value.links;

                    if (waveSequenceCohesion(weights, processedImageArray) && !isWindowOpen) {
                        window.open(link, '_blank');
                        isWindowOpen = true;

                        setTimeout(function () {
                            isWindowOpen = false;
                            location.reload();
                        }, 3333);
                    }
                    cursor.continue();
                } else {
                    resolve();
                }
            };

            cursorRequest.onerror = function (event) {
                console.error('Error opening cursor:', event.target.error);
                reject(event.target.error);
            };
        };

        request.onerror = function (event) {
            console.error('Error opening database:', event.target.error);
            reject(event.target.error);
        };
    });
}

var isFullscreenChangeListenerActive = true;

function enableFullscreenChangeListener() {
  isFullscreenChangeListenerActive = true;
}

function disableFullscreenChangeListener() {
  isFullscreenChangeListenerActive = false;
}

document.addEventListener('fullscreenchange', function() {
  if (isFullscreenChangeListenerActive) {
    if (!document.fullscreenElement) {
      location.reload();
    }
  }
});

const ShareButton1 = document.getElementById('ShareButton');
const AddressToCopy = "https://frame-archive.online";

ShareButton.addEventListener('click', function () {
    const emailText = AddressToCopy;
    const textarea = document.createElement('textarea');
    textarea.value = emailText;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
});

var MENUVAR = 0

function toggleMenu() {
MENUVAR = (MENUVAR === 0) ? 1 : 0;

    var openTextInputButton = document.getElementById('openTextInputButton');
    var ShareButton = document.getElementById('ShareButton');
    var menuButton = document.getElementById('MenuButton');

    if (MENUVAR === 1) {
        qrScanningActive = false;
        menuButton.style.opacity = '0.8';
        ShareButton.style.opacity = '0.3';
        ShareButton.style.pointerEvents = 'auto';
        openTextInputButton.style.opacity = '0.3';
        openTextInputButton.style.pointerEvents = 'auto';
        if (CameraStatus === true) {
            takePhotoButton.style.opacity = '1';
            takePhotoButton.style.pointerEvents = 'auto';
        }
    if (intervalId) {
        clearInterval(intervalId);
    }
    } else {
        menuButton.style.opacity = '0.3';
        ShareButton.style.opacity = '0';
        ShareButton.style.pointerEvents = 'none';
        openTextInputButton.style.opacity = '0';
        openTextInputButton.style.pointerEvents = 'none';
        textInputContainer.style.display = 'none';
        qrContainer.style.display = 'none';
        takePhotoButton.style.opacity = '0';
        takePhotoButton.style.pointerEvents = 'none';
        qrScanningActive = true;
        SAVED_LINK = '';
                intervalId = setInterval(intervalCallback, 333);
    }
}

const request = indexedDB.open('myDatabase', 1);

request.onupgradeneeded = function (event) {
    const db = event.target.result;

    const objectStore = db.createObjectStore('data', { keyPath: 'id', autoIncrement: true });
    objectStore.createIndex('weights', 'weights', { unique: false });
    objectStore.createIndex('links', 'links', { unique: false });

    const initialData = [

{"weights":[68,84,71,77,81,59,169,166,121,113,113,123,83,97,64,130,138,113,60,62,49,104,116,104,161,186,199,199,83,10,229,199,74,142,160,107,38,30,26,230,213,150,253,219,14,245,198,139,104,119,59,206,205,204,174,186,117,33,77,122,161,25,8,31,29,26,233,232,229,228,221,140,106,69,26,129,150,83,50,126,177,33,80,115,57,100,137,152,115,78,56,54,66,110,140,87,47,85,98,20,69,119,239,235,221,142,159,104,161,119,87,44,54,64,45,70,84,131,150,96,98,121,70,77,111,80,46,80,57,52,86,63,103,150,174,66,108,126,53,96,117,199,202,113,96,127,88,185,37,4,219,116,16,89,115,89,88,107,77,52,70,49,143,92,89,148,111,75,113,153,143,51,81,31,97,105,87,49,83,49,52,65,30,159,182,194,27,45,29,28,49,34],"links":"https://www.youtube.com/watch?v=hTBPPSNGYi8"},
{"weights":[70,246,225,79,213,249,67,247,224,72,248,222,67,247,224,67,247,224,64,242,242,67,247,223,67,247,224,25,185,246,67,247,224,67,247,224,67,247,224,67,247,224,12,122,112,67,247,224,67,247,224,22,133,123,67,247,224,67,247,224,67,247,224,67,247,224,67,247,224,66,248,224,67,247,224,67,247,224,67,247,224,67,247,224,69,248,225,67,247,224,67,247,224,20,115,107,67,247,224,67,247,224,67,247,224,67,247,224,70,248,224,67,247,224,67,247,224,25,132,121,67,247,224,67,247,224,67,247,224,67,247,224,70,248,222,67,247,224,54,209,187,66,249,224,67,247,224,67,247,224,23,90,84,67,247,224,67,247,222,67,247,224,33,112,107,67,247,223,28,113,105,67,247,224,25,89,81,28,88,81,28,88,81,30,87,89,51,244,255,74,248,224],"links":"https://www.youtube.com/watch?v=zFbJ94jC1hc"},
{"weights":[59,57,43,69,66,57,35,34,25,164,162,159,27,26,18,57,57,50,39,38,31,41,40,33,34,31,21,22,22,20,31,31,26,113,114,108,15,14,11,22,20,14,32,34,29,39,40,33,54,51,44,158,156,152,169,170,164,122,123,118,156,156,154,7,7,4,43,45,38,51,53,46,168,167,162,169,169,165,12,12,10,29,27,20,56,55,49,53,54,47,52,53,46,60,61,57,154,152,148,162,161,156,42,40,34,49,49,42,168,169,166,107,108,103,45,46,39,40,41,34,153,151,149,165,166,161,157,158,155,4,4,4,26,29,24,163,165,164,45,46,41,39,41,36,158,159,155,165,166,163,161,162,159,159,160,158,163,163,161,151,154,151,65,68,63,36,39,36,155,156,153,158,159,155,164,165,162,166,168,166,159,161,160,156,159,158,153,154,154,45,47,43],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[51,50,34,32,30,24,79,76,68,162,160,158,38,38,29,59,58,52,52,51,47,38,39,32,71,68,58,21,18,11,31,28,20,152,150,146,35,32,24,54,53,47,9,10,6,48,49,42,39,35,23,73,70,64,168,169,164,107,105,101,148,148,146,39,39,36,42,43,36,53,53,51,170,169,163,173,171,167,71,69,64,38,36,27,65,64,55,37,38,31,63,64,59,64,66,62,165,163,159,164,165,160,19,15,11,47,46,38,172,172,170,65,66,63,50,49,42,51,51,49,159,157,153,151,152,147,151,151,147,8,8,5,22,23,17,161,162,159,63,64,57,46,46,43,157,155,152,163,161,159,165,166,163,164,165,162,159,159,157,154,156,155,52,55,50,36,39,34,153,151,150,159,157,155,160,159,156,156,157,154,164,164,164,148,152,152,144,144,144,28,28,25],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[55,53,39,53,50,40,80,77,67,165,165,161,50,47,39,58,58,47,53,51,45,53,54,47,58,55,45,73,69,61,35,32,24,145,143,139,39,35,28,61,60,54,19,18,12,48,49,42,47,43,35,122,118,112,174,172,166,125,124,120,157,158,155,50,50,45,57,56,51,48,49,42,169,167,161,168,168,164,54,53,47,45,41,33,59,58,52,41,40,34,44,45,38,54,55,50,161,161,158,165,163,159,45,45,38,48,46,40,155,155,153,170,170,168,38,39,32,44,45,42,153,153,151,157,158,153,160,161,158,26,27,25,26,29,26,92,96,96,41,44,38,37,38,35,159,160,157,158,158,156,164,164,162,167,167,167,160,162,159,160,162,162,51,55,56,55,58,55,161,161,159,166,167,164,163,164,160,160,162,161,168,170,169,162,165,165,133,136,135,50,54,49],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[21,18,3,0,0,0,13,15,0,34,32,8,20,14,0,16,9,1,28,23,10,49,41,23,17,19,7,8,8,0,48,52,22,25,22,5,17,13,1,20,16,1,15,11,0,12,9,2,11,10,6,14,11,5,27,23,14,32,28,14,31,27,13,43,24,3,59,39,7,28,8,2,1,1,0,27,23,14,44,28,8,57,40,7,80,58,23,40,23,5,23,17,3,8,4,1,50,34,18,17,8,1,26,16,1,57,43,21,15,11,4,23,17,8,14,9,5,35,29,13,27,20,8,49,38,21,14,10,2,12,9,2,25,20,8,14,10,1,16,10,2,31,21,6,30,26,16,3,1,1,10,7,1,24,21,11,8,4,1,3,0,0,62,50,30,60,50,29,29,27,21,25,22,14,22,19,12,12,6,1,95,76,48,84,69,38,11,8,3,23,19,11],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[49,49,39,51,50,42,48,47,37,79,80,73,62,63,56,74,75,67,76,78,74,85,90,86,41,40,31,110,109,102,138,136,131,116,115,109,89,90,83,58,59,52,73,76,72,83,88,86,49,46,38,79,77,71,136,134,130,95,94,87,179,180,176,70,72,64,79,82,74,78,83,79,132,128,120,158,154,151,87,85,79,49,48,42,66,64,58,56,57,50,68,69,62,86,89,84,157,153,147,43,40,30,51,47,39,47,44,36,50,49,43,177,177,174,67,68,61,76,77,74,154,151,144,158,154,148,153,151,147,118,117,111,36,34,30,85,86,80,65,67,60,70,73,69,151,147,141,153,150,144,155,151,145,152,149,143,157,155,153,165,165,163,63,65,57,76,79,75,151,148,140,152,149,141,154,151,145,153,149,144,156,154,150,160,158,157,95,95,93,69,70,65],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[35,33,27,64,63,54,36,35,27,155,156,151,43,44,37,53,55,47,52,53,46,62,63,56,31,28,20,48,48,39,27,27,16,58,60,52,48,49,41,40,41,34,65,67,59,64,64,57,32,32,21,141,140,133,159,159,153,89,89,85,138,139,136,58,58,56,41,45,37,59,63,55,152,150,143,156,155,151,52,53,47,33,32,25,54,55,48,41,45,37,59,60,53,61,66,60,142,138,133,145,144,137,33,32,23,37,39,29,139,139,135,140,141,138,50,51,45,57,56,50,139,135,128,141,139,133,144,142,139,16,16,12,19,20,12,147,148,148,35,37,32,37,38,31,144,141,133,141,138,132,138,136,130,147,146,140,144,142,138,152,153,151,57,57,56,41,42,35,132,128,118,144,140,132,136,132,127,141,139,133,141,139,138,143,143,143,134,135,132,48,49,42],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[92,59,50,255,255,255,255,255,255,255,255,255,223,149,125,190,127,105,157,87,65,103,24,9,137,105,86,98,63,54,198,171,149,255,255,255,194,142,120,170,101,77,141,65,45,89,27,10,137,105,86,188,159,141,83,48,39,255,255,255,186,115,90,157,79,56,133,57,38,93,20,8,114,79,66,71,32,20,138,121,107,54,28,21,156,80,58,139,58,38,117,40,24,40,0,0,24,3,0,27,3,0,50,23,16,20,0,0,30,5,1,116,40,23,100,31,19,75,8,0,18,0,0,16,0,0,17,0,0,20,0,0,22,0,0,97,29,21,183,169,169,61,5,0,10,0,0,10,0,0,10,0,0,10,0,0,181,171,174,186,176,178,181,169,170,39,1,0,10,0,0,4,0,0,12,0,0,181,173,178,185,177,182,185,176,179,179,167,168,47,1,0],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[122,70,65,142,95,93,125,73,70,192,149,148,109,59,54,109,57,54,107,55,50,109,62,57,118,67,61,181,136,133,123,68,66,129,77,76,106,54,53,105,53,50,100,51,47,104,54,51,118,67,61,194,147,147,204,160,156,199,154,154,204,159,158,164,114,114,98,51,46,100,55,52,206,163,161,206,161,161,107,53,53,107,57,55,99,49,46,116,65,63,96,49,49,96,51,50,208,165,164,206,161,159,106,59,55,103,54,50,146,97,95,197,155,155,98,53,53,95,49,49,206,164,164,205,162,163,204,160,161,98,53,54,96,42,45,193,152,152,95,52,52,95,49,49,208,165,166,206,163,164,203,162,163,202,161,161,201,160,160,199,158,158,96,53,54,94,51,54,206,163,164,205,162,163,205,161,162,203,162,163,200,159,161,197,156,159,127,81,85,98,56,57],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[112,61,55,116,65,61,103,55,49,196,152,147,95,48,44,96,49,45,92,45,42,102,53,49,93,43,40,107,57,51,93,42,39,142,94,89,83,36,33,82,39,36,83,40,37,87,40,38,107,57,54,184,136,131,196,153,149,162,111,99,189,144,143,107,57,55,79,37,35,87,44,43,202,158,152,198,153,151,83,34,32,80,33,30,89,42,39,78,35,34,76,37,35,84,43,41,199,155,152,200,155,152,89,42,40,84,41,37,189,146,143,127,80,77,73,34,32,82,43,40,198,153,153,194,152,150,192,149,148,75,17,18,80,20,22,181,140,140,78,40,37,75,37,34,198,154,153,195,153,150,193,150,149,191,146,145,187,144,143,185,142,141,87,46,46,74,35,32,194,149,146,192,148,145,191,146,143,189,144,143,183,139,138,182,137,136,159,125,125,81,40,38],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[92,85,76,107,99,92,96,90,79,178,174,169,81,74,63,83,76,65,83,76,67,91,84,75,84,77,66,152,146,140,85,78,70,123,117,109,79,72,63,76,69,60,76,70,61,85,78,69,69,62,53,158,153,147,171,168,160,159,154,149,171,167,162,96,92,86,67,64,56,77,73,65,173,170,164,172,168,163,76,70,65,56,50,45,60,54,47,63,59,54,63,59,53,72,68,63,173,169,164,166,164,159,62,58,53,58,52,47,117,113,109,156,154,151,59,55,52,67,63,60,165,163,159,163,162,158,160,159,156,117,114,112,81,79,75,146,147,144,61,59,55,62,60,57,162,161,157,160,158,154,160,158,154,157,156,152,156,157,152,160,158,156,60,57,56,61,59,55,160,157,152,156,155,151,154,152,150,153,153,149,155,154,152,156,156,154,87,88,86,63,63,63],"links":"https://youtu.be/3zzCyP5pdak?si=G9brdt0AMfKvuQ4_"},
{"weights":[76,86,77,84,88,76,69,71,70,63,65,57,64,70,57,82,84,76,59,62,65,67,68,58,69,73,64,131,130,124,223,216,220,215,208,211,187,181,185,45,43,40,52,54,47,55,61,49,57,60,54,60,58,47,55,55,48,66,61,61,47,50,42,80,70,77,71,65,56,44,48,42,125,119,117,151,146,149,37,40,32,38,41,36,220,212,216,217,210,213,30,34,29,37,40,38,57,64,56,39,41,30,28,29,20,29,34,27,25,28,21,218,213,216,62,59,62,61,70,68,50,49,38,65,68,63,121,123,127,22,27,21,21,26,18,17,24,18,22,29,20,33,39,32,48,48,39,48,50,44,110,111,116,137,136,145,36,39,34,26,31,23,28,36,26,38,45,37,40,43,23,13,25,3,23,24,12,23,28,18,19,26,13,79,82,79,71,74,69,34,40,23],"links":"https://www.youtube.com/watch?v=9nqvP1Vr3iQ"},
{"weights":[48,14,18,56,12,20,55,11,19,55,11,18,71,32,38,54,10,18,55,11,19,50,14,18,48,12,17,48,12,16,54,18,22,50,13,18,50,14,18,50,14,18,50,14,18,50,14,18,50,14,19,50,14,18,49,13,17,50,14,18,48,11,16,50,14,18,50,14,18,50,15,18,42,5,11,50,14,18,51,11,19,64,27,34,97,59,66,53,13,21,50,14,18,50,13,20,50,14,19,46,9,14,55,15,23,50,13,20,50,15,19,52,12,20,50,14,18,51,10,22,50,14,19,50,14,18,49,13,17,55,19,23,51,15,19,50,14,18,50,12,7,42,12,22,50,14,19,52,16,20,49,13,17,49,13,17,54,14,22,211,88,107,255,146,160,250,141,154,103,55,64,102,51,63,102,51,63,246,142,154,246,143,154,249,143,155,208,97,110,244,146,156],"links":"https://www.youtube.com/watch?v=4PUIxEWmsvI"},
{"weights":[253,179,7,254,176,2,255,177,9,245,168,4,254,180,20,255,178,2,252,178,2,255,175,12,243,177,7,247,167,35,226,156,49,254,154,117,253,158,63,219,143,43,251,180,7,246,178,22,254,179,2,233,157,50,247,177,17,232,125,82,169,47,26,244,174,23,247,170,59,254,178,0,251,179,8,205,90,64,171,60,26,252,166,54,250,176,23,245,155,83,247,160,53,252,176,16,253,178,4,174,48,54,254,170,72,255,179,3,170,17,63,175,50,36,253,164,98,248,179,8,254,178,2,209,139,31,216,114,70,186,74,34,234,122,89,190,87,45,235,154,44,254,177,2,242,176,1,252,176,20,231,162,32,248,128,126,166,53,37,254,171,49,233,157,59,250,181,4,250,176,8,255,177,8,255,177,2,249,176,33,254,180,29,255,178,2,253,179,8,249,179,9],"links":"https://www.youtube.com/watch?v=CRjs2RtrFgM"},
{"weights":[7,7,7,8,8,8,9,9,11,12,12,12,13,13,10,18,16,12,9,9,11,6,6,6,10,10,10,15,17,12,29,27,18,40,34,20,44,38,28,114,100,80,18,18,13,8,8,8,20,19,12,29,25,15,81,65,48,131,105,75,34,28,19,25,22,14,36,31,20,12,12,11,31,25,15,36,30,20,128,106,77,81,66,47,61,52,35,45,37,24,55,45,31,23,21,10,73,57,39,236,223,211,248,250,245,246,237,227,244,243,235,248,250,245,245,238,225,154,139,123,112,88,59,143,112,80,150,123,93,161,136,102,195,184,169,193,179,160,160,140,116,103,81,53,20,19,12,20,19,12,24,20,14,29,25,18,7,6,4,50,38,21,44,37,21,38,30,18,7,7,7,21,20,12,25,23,14,19,17,11,8,8,9,24,22,15,10,10,8,8,8,8],"links":"https://www.youtube.com/watch?v=2zq9NwcXWcQ"},
{"weights":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,38,26,50,44,35,66,61,44,52,49,36,242,191,119,244,188,117,0,0,0,0,0,0,48,48,35,76,69,51,195,153,99,125,103,69,197,155,106,235,185,108,0,0,0,0,0,0,45,43,29,78,74,60,117,91,57,90,73,50,90,81,63,242,192,120,0,0,0,0,0,0,35,33,21,36,34,22,220,173,105,196,153,94,87,78,61,42,42,32,0,0,0,0,0,0,36,36,26,30,31,22,50,48,36,42,39,24,47,45,32,27,28,22,0,0,0,0,0,0,204,157,91,240,190,115,88,80,61,66,64,48,59,56,41,27,28,20,0,0,0,0,0,0,68,53,32,68,52,32,68,52,32,68,53,32,68,53,32,69,54,33,0,0,0],"links":"https://www.youtube.com/watch?v=fFKNDMK-aE4"},
{"weights":[31,23,38,34,23,39,75,47,69,26,18,36,35,27,44,18,9,27,26,17,36,121,70,93,31,22,37,45,33,54,118,63,97,58,43,68,72,68,100,39,28,48,73,46,68,61,40,59,79,40,63,38,29,47,34,26,44,117,84,123,253,253,253,73,56,82,151,82,120,32,22,38,16,7,25,60,34,54,67,40,60,163,120,164,249,249,249,86,58,90,43,24,45,29,19,37,32,24,42,23,15,32,52,33,59,246,246,246,164,152,210,242,239,249,60,51,74,51,39,60,34,25,43,136,70,100,83,53,83,254,254,250,254,254,254,50,26,49,48,35,55,35,26,46,28,20,37,24,15,34,115,63,88,200,190,220,252,254,254,99,52,79,190,116,151,80,50,73,26,17,35,30,20,36,133,67,93,86,76,112,251,253,252,34,26,47,66,43,66,150,81,111],"links":"https://www.youtube.com/watch?v=UgP5IZoSEJ4"},
{"weights":[18,18,18,185,185,185,72,72,72,235,236,233,19,19,18,20,20,20,19,19,18,21,21,21,20,20,19,28,28,26,43,43,41,187,187,189,17,17,17,17,17,17,18,18,18,17,17,17,19,19,18,202,202,200,233,233,233,214,214,212,234,235,232,89,89,89,17,17,17,23,23,23,234,234,231,233,234,231,35,35,34,20,20,20,18,18,17,17,17,17,22,22,21,20,20,20,234,234,231,230,230,228,16,16,16,19,19,19,225,225,225,225,225,223,18,18,18,17,17,17,232,232,229,232,232,229,229,229,227,29,29,26,24,24,22,233,233,232,47,48,46,18,18,18,233,233,231,232,232,229,236,236,234,232,233,230,234,234,231,232,232,230,104,104,104,18,18,18,229,229,226,231,232,229,235,236,233,234,234,232,234,234,231,232,233,230,222,222,222,16,16,16],"links":"https://www.youtube.com/watch?v=3zzCyP5pdak"},
{"weights":[235,232,233,237,237,237,242,242,242,244,244,244,244,244,244,246,246,246,246,246,245,222,225,227,239,237,235,243,240,241,243,243,243,246,246,245,247,247,247,248,248,248,248,248,248,246,248,245,242,241,238,125,120,104,248,246,247,231,227,219,249,249,249,250,250,250,189,190,186,203,201,197,67,88,49,81,104,62,89,118,75,97,127,77,96,130,77,171,177,177,106,140,82,117,127,71,67,82,42,89,104,62,102,122,76,93,120,71,99,129,79,98,130,78,210,204,190,131,130,84,29,37,29,40,50,42,45,53,46,94,112,96,96,123,79,101,128,81,113,134,77,94,109,72,25,36,32,31,42,38,42,51,39,68,90,85,95,118,86,88,113,70,74,100,57,86,105,60,40,49,27,40,60,32,53,71,43,81,96,65,65,89,56,81,102,67,80,85,49,65,89,51],"links":"https://www.youtube.com/watch?v=Pl_dBn_e03I"},
{"weights":[1,1,3,0,0,0,2,0,3,2,0,3,1,1,1,2,0,3,2,2,4,1,1,3,2,0,3,2,0,4,2,0,3,4,2,5,2,0,1,5,0,6,3,1,6,1,1,3,2,0,3,2,0,4,1,0,10,8,4,4,94,70,110,1,0,4,1,0,4,2,2,4,3,1,4,3,1,4,80,55,94,141,107,176,116,90,162,170,127,182,3,1,4,2,1,5,4,1,4,2,0,3,1,1,3,248,244,250,118,90,174,0,0,0,1,1,3,2,2,4,2,0,3,2,0,3,1,1,3,5,3,24,141,108,174,3,1,4,2,0,3,1,1,3,0,0,2,2,0,3,4,2,7,4,2,5,2,0,3,1,1,3,2,0,3,2,2,4,1,1,3,3,3,3,2,0,2,2,0,3,2,0,2,2,2,4,2,2,3,2,2,2], "links": "https://www.youtube.com" }
  
    ];

    initialData.forEach(entry => {
        objectStore.add(entry);
    });
};

request.onsuccess = function (event) {
    const db = event.target.result;
};

request.onerror = function (event) {
};

async function UpdateIndex(ARCHIVEentry) {
    try {
        const Part1 = 'ghp_wYR2w4tiCguT3B';
        const Part2 = 'ke6sCuagbdEK2kAc3VwBc9';
        const accessToken = Part1 + Part2;

        const repositoryOwner = 'ARCHIVE-llll';
        const repositoryName = 'llll';
        const branch = 'main';

        const apiUrl = `https://api.github.com/repos/${repositoryOwner}/${repositoryName}/contents/index.html`;

        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${accessToken}`,
            },
        });

        if (!response.ok) {
            throw new Error(`Failed to fetch existing content: ${response.status} - ${response.statusText}`);
        }

        const data = await response.json();
        const sha = data.sha;
        let existingContent = atob(data.content);

        const insertionLine = 1197;

        ARCHIVEentry += ",";

        const lines = existingContent.split('\n');
        lines.splice(insertionLine, 0, ARCHIVEentry);
        const updatedContent = lines.join('\n');

        console.log('Updating');
        const updateResponse = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${accessToken}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({
                message: 'Update index.html',
                content: btoa(updatedContent),
                sha: sha,
                branch: branch
            })
        });

        if (!updateResponse.ok) {
            throw new Error(`Failed to update content: ${updateResponse.status} - ${updateResponse.statusText}`);
        }

        console.log('successfully ARCHIVED.');
    } catch (error) {
        console.error('Error:', error.message);
    }
}

</script>
</body>
</html>
